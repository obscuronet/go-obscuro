package simulation

import (
	"testing"
)

// This test creates a network of in memory L1 and L2 nodes, then injects transactions, and finally checks the resulting output blockchain.
// Running it long enough with various parameters will test many corner cases without having to explicitly write individual tests for them.
// The unit of time is the "AvgBlockDurationUSecs" - which is the average time between L1 blocks, which are the carriers of rollups.
// Everything else is reported to this value. This number has to be adjusted in conjunction with the number of nodes. If it's too low,
// the CPU usage will be very high during the simulation which might result in inconclusive results.
func TestInMemoryMonteCarloSimulation(t *testing.T) {
	logFile := setupTestLog()
	defer logFile.Close()

	params := SimParams{
		NumberOfNodes:         10,
		NumberOfWallets:       5,
		AvgBlockDurationUSecs: uint64(40_000),
		SimulationTimeSecs:    15,
	}
	params.AvgNetworkLatency = params.AvgBlockDurationUSecs / 15
	params.AvgGossipPeriod = params.AvgBlockDurationUSecs / 3
	params.SimulationTimeUSecs = params.SimulationTimeSecs * 1000 * 1000

	efficiencies := EfficiencyThresholds{0.2, 0.32, 0.34}

	testSimulation(t, CreateBasicNetworkOfInMemoryNodes, params, efficiencies)
}
