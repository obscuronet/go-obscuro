// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: go/obscuronode/enclave/rpc/enclave.proto

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// EnclaveClient is the client API for Enclave service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EnclaveClient interface {
	// Attestation - Produces an attestation report which will be used to request the shared secret from another enclave.
	Attestation(ctx context.Context, in *AttestationRequest, opts ...grpc.CallOption) (*AttestationResponse, error)
	// GenerateSecret - the genesis enclave is responsible with generating the secret entropy
	GenerateSecret(ctx context.Context, in *GenerateSecretRequest, opts ...grpc.CallOption) (*GenerateSecretResponse, error)
	// FetchSecret - return the shared secret encrypted with the key from the attestation
	FetchSecret(ctx context.Context, in *FetchSecretRequest, opts ...grpc.CallOption) (*FetchSecretResponse, error)
	// Init - initialise an enclave with a seed received by another enclave
	Init(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitResponse, error)
	// IsInitialised - true if the shared secret is available
	IsInitialised(ctx context.Context, in *IsInitialisedRequest, opts ...grpc.CallOption) (*IsInitialisedResponse, error)
	// ProduceGenesis - the genesis enclave produces the genesis rollup
	ProduceGenesis(ctx context.Context, in *ProduceGenesisRequest, opts ...grpc.CallOption) (*ProduceGenesisResponse, error)
	// IngestBlocks - feed L1 blocks into the enclave to catch up
	IngestBlocks(ctx context.Context, in *IngestBlocksRequest, opts ...grpc.CallOption) (*IngestBlocksResponse, error)
	// Start - start speculative execution
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error)
	// SubmitBlock - When a new POBI round starts, the host submits a block to the enclave, which responds with a rollup
	// it is the responsibility of the host to gossip the returned rollup
	// For good functioning the caller should always submit blocks ordered by height
	// submitting a block before receiving a parent of it, will result in it being ignored
	SubmitBlock(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error)
	// SubmitRollup - receive gossiped rollups
	SubmitRollup(ctx context.Context, in *SubmitRollupRequest, opts ...grpc.CallOption) (*SubmitRollupResponse, error)
	// SubmitTx - user transactions
	SubmitTx(ctx context.Context, in *SubmitTxRequest, opts ...grpc.CallOption) (*SubmitTxResponse, error)
	// Balance - returns the balance of an address with a block delay
	Balance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceResponse, error)
	// RoundWinner - calculates and returns the winner for a round
	RoundWinner(ctx context.Context, in *RoundWinnerRequest, opts ...grpc.CallOption) (*RoundWinnerResponse, error)
	// Stop gracefully stops the enclave
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)
	// GetTransaction returns a transaction given its Signed Hash, returns nil, false when Transaction is unknown
	GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error)
}

type enclaveClient struct {
	cc grpc.ClientConnInterface
}

func NewEnclaveClient(cc grpc.ClientConnInterface) EnclaveClient {
	return &enclaveClient{cc}
}

func (c *enclaveClient) Attestation(ctx context.Context, in *AttestationRequest, opts ...grpc.CallOption) (*AttestationResponse, error) {
	out := new(AttestationResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/Attestation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) GenerateSecret(ctx context.Context, in *GenerateSecretRequest, opts ...grpc.CallOption) (*GenerateSecretResponse, error) {
	out := new(GenerateSecretResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/GenerateSecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) FetchSecret(ctx context.Context, in *FetchSecretRequest, opts ...grpc.CallOption) (*FetchSecretResponse, error) {
	out := new(FetchSecretResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/FetchSecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) Init(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitResponse, error) {
	out := new(InitResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/Init", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) IsInitialised(ctx context.Context, in *IsInitialisedRequest, opts ...grpc.CallOption) (*IsInitialisedResponse, error) {
	out := new(IsInitialisedResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/IsInitialised", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) ProduceGenesis(ctx context.Context, in *ProduceGenesisRequest, opts ...grpc.CallOption) (*ProduceGenesisResponse, error) {
	out := new(ProduceGenesisResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/ProduceGenesis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) IngestBlocks(ctx context.Context, in *IngestBlocksRequest, opts ...grpc.CallOption) (*IngestBlocksResponse, error) {
	out := new(IngestBlocksResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/IngestBlocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error) {
	out := new(StartResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) SubmitBlock(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error) {
	out := new(SubmitBlockResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/SubmitBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) SubmitRollup(ctx context.Context, in *SubmitRollupRequest, opts ...grpc.CallOption) (*SubmitRollupResponse, error) {
	out := new(SubmitRollupResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/SubmitRollup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) SubmitTx(ctx context.Context, in *SubmitTxRequest, opts ...grpc.CallOption) (*SubmitTxResponse, error) {
	out := new(SubmitTxResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/SubmitTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) Balance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceResponse, error) {
	out := new(BalanceResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/Balance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) RoundWinner(ctx context.Context, in *RoundWinnerRequest, opts ...grpc.CallOption) (*RoundWinnerResponse, error) {
	out := new(RoundWinnerResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/RoundWinner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {
	out := new(StopResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveClient) GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error) {
	out := new(GetTransactionResponse)
	err := c.cc.Invoke(ctx, "/rpc.Enclave/GetTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EnclaveServer is the server API for Enclave service.
// All implementations must embed UnimplementedEnclaveServer
// for forward compatibility
type EnclaveServer interface {
	// Attestation - Produces an attestation report which will be used to request the shared secret from another enclave.
	Attestation(context.Context, *AttestationRequest) (*AttestationResponse, error)
	// GenerateSecret - the genesis enclave is responsible with generating the secret entropy
	GenerateSecret(context.Context, *GenerateSecretRequest) (*GenerateSecretResponse, error)
	// FetchSecret - return the shared secret encrypted with the key from the attestation
	FetchSecret(context.Context, *FetchSecretRequest) (*FetchSecretResponse, error)
	// Init - initialise an enclave with a seed received by another enclave
	Init(context.Context, *InitRequest) (*InitResponse, error)
	// IsInitialised - true if the shared secret is available
	IsInitialised(context.Context, *IsInitialisedRequest) (*IsInitialisedResponse, error)
	// ProduceGenesis - the genesis enclave produces the genesis rollup
	ProduceGenesis(context.Context, *ProduceGenesisRequest) (*ProduceGenesisResponse, error)
	// IngestBlocks - feed L1 blocks into the enclave to catch up
	IngestBlocks(context.Context, *IngestBlocksRequest) (*IngestBlocksResponse, error)
	// Start - start speculative execution
	Start(context.Context, *StartRequest) (*StartResponse, error)
	// SubmitBlock - When a new POBI round starts, the host submits a block to the enclave, which responds with a rollup
	// it is the responsibility of the host to gossip the returned rollup
	// For good functioning the caller should always submit blocks ordered by height
	// submitting a block before receiving a parent of it, will result in it being ignored
	SubmitBlock(context.Context, *SubmitBlockRequest) (*SubmitBlockResponse, error)
	// SubmitRollup - receive gossiped rollups
	SubmitRollup(context.Context, *SubmitRollupRequest) (*SubmitRollupResponse, error)
	// SubmitTx - user transactions
	SubmitTx(context.Context, *SubmitTxRequest) (*SubmitTxResponse, error)
	// Balance - returns the balance of an address with a block delay
	Balance(context.Context, *BalanceRequest) (*BalanceResponse, error)
	// RoundWinner - calculates and returns the winner for a round
	RoundWinner(context.Context, *RoundWinnerRequest) (*RoundWinnerResponse, error)
	// Stop gracefully stops the enclave
	Stop(context.Context, *StopRequest) (*StopResponse, error)
	// GetTransaction returns a transaction given its Signed Hash, returns nil, false when Transaction is unknown
	GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error)
	mustEmbedUnimplementedEnclaveServer()
}

// UnimplementedEnclaveServer must be embedded to have forward compatible implementations.
type UnimplementedEnclaveServer struct {
}

func (UnimplementedEnclaveServer) Attestation(context.Context, *AttestationRequest) (*AttestationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attestation not implemented")
}
func (UnimplementedEnclaveServer) GenerateSecret(context.Context, *GenerateSecretRequest) (*GenerateSecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateSecret not implemented")
}
func (UnimplementedEnclaveServer) FetchSecret(context.Context, *FetchSecretRequest) (*FetchSecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchSecret not implemented")
}
func (UnimplementedEnclaveServer) Init(context.Context, *InitRequest) (*InitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Init not implemented")
}
func (UnimplementedEnclaveServer) IsInitialised(context.Context, *IsInitialisedRequest) (*IsInitialisedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsInitialised not implemented")
}
func (UnimplementedEnclaveServer) ProduceGenesis(context.Context, *ProduceGenesisRequest) (*ProduceGenesisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProduceGenesis not implemented")
}
func (UnimplementedEnclaveServer) IngestBlocks(context.Context, *IngestBlocksRequest) (*IngestBlocksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IngestBlocks not implemented")
}
func (UnimplementedEnclaveServer) Start(context.Context, *StartRequest) (*StartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (UnimplementedEnclaveServer) SubmitBlock(context.Context, *SubmitBlockRequest) (*SubmitBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitBlock not implemented")
}
func (UnimplementedEnclaveServer) SubmitRollup(context.Context, *SubmitRollupRequest) (*SubmitRollupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitRollup not implemented")
}
func (UnimplementedEnclaveServer) SubmitTx(context.Context, *SubmitTxRequest) (*SubmitTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTx not implemented")
}
func (UnimplementedEnclaveServer) Balance(context.Context, *BalanceRequest) (*BalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Balance not implemented")
}
func (UnimplementedEnclaveServer) RoundWinner(context.Context, *RoundWinnerRequest) (*RoundWinnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoundWinner not implemented")
}
func (UnimplementedEnclaveServer) Stop(context.Context, *StopRequest) (*StopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedEnclaveServer) GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransaction not implemented")
}
func (UnimplementedEnclaveServer) mustEmbedUnimplementedEnclaveServer() {}

// UnsafeEnclaveServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EnclaveServer will
// result in compilation errors.
type UnsafeEnclaveServer interface {
	mustEmbedUnimplementedEnclaveServer()
}

func RegisterEnclaveServer(s grpc.ServiceRegistrar, srv EnclaveServer) {
	s.RegisterService(&Enclave_ServiceDesc, srv)
}

func _Enclave_Attestation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).Attestation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/Attestation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).Attestation(ctx, req.(*AttestationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_GenerateSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).GenerateSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/GenerateSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).GenerateSecret(ctx, req.(*GenerateSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_FetchSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).FetchSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/FetchSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).FetchSecret(ctx, req.(*FetchSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_Init_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).Init(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/Init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).Init(ctx, req.(*InitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_IsInitialised_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsInitialisedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).IsInitialised(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/IsInitialised",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).IsInitialised(ctx, req.(*IsInitialisedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_ProduceGenesis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProduceGenesisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).ProduceGenesis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/ProduceGenesis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).ProduceGenesis(ctx, req.(*ProduceGenesisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_IngestBlocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestBlocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).IngestBlocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/IngestBlocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).IngestBlocks(ctx, req.(*IngestBlocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).Start(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_SubmitBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).SubmitBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/SubmitBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).SubmitBlock(ctx, req.(*SubmitBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_SubmitRollup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitRollupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).SubmitRollup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/SubmitRollup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).SubmitRollup(ctx, req.(*SubmitRollupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_SubmitTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).SubmitTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/SubmitTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).SubmitTx(ctx, req.(*SubmitTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_Balance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).Balance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/Balance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).Balance(ctx, req.(*BalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_RoundWinner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoundWinnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).RoundWinner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/RoundWinner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).RoundWinner(ctx, req.(*RoundWinnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Enclave_GetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveServer).GetTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Enclave/GetTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveServer).GetTransaction(ctx, req.(*GetTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Enclave_ServiceDesc is the grpc.ServiceDesc for Enclave service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Enclave_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.Enclave",
	HandlerType: (*EnclaveServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Attestation",
			Handler:    _Enclave_Attestation_Handler,
		},
		{
			MethodName: "GenerateSecret",
			Handler:    _Enclave_GenerateSecret_Handler,
		},
		{
			MethodName: "FetchSecret",
			Handler:    _Enclave_FetchSecret_Handler,
		},
		{
			MethodName: "Init",
			Handler:    _Enclave_Init_Handler,
		},
		{
			MethodName: "IsInitialised",
			Handler:    _Enclave_IsInitialised_Handler,
		},
		{
			MethodName: "ProduceGenesis",
			Handler:    _Enclave_ProduceGenesis_Handler,
		},
		{
			MethodName: "IngestBlocks",
			Handler:    _Enclave_IngestBlocks_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _Enclave_Start_Handler,
		},
		{
			MethodName: "SubmitBlock",
			Handler:    _Enclave_SubmitBlock_Handler,
		},
		{
			MethodName: "SubmitRollup",
			Handler:    _Enclave_SubmitRollup_Handler,
		},
		{
			MethodName: "SubmitTx",
			Handler:    _Enclave_SubmitTx_Handler,
		},
		{
			MethodName: "Balance",
			Handler:    _Enclave_Balance_Handler,
		},
		{
			MethodName: "RoundWinner",
			Handler:    _Enclave_RoundWinner_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _Enclave_Stop_Handler,
		},
		{
			MethodName: "GetTransaction",
			Handler:    _Enclave_GetTransaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/obscuronode/enclave/rpc/enclave.proto",
}
