// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: go/obscuronode/enclave/rpc/enclave.proto

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// EnclaveInternalClient is the client API for EnclaveInternal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EnclaveInternalClient interface {
	// Attestation - Produces an attestation report which will be used to request the shared secret from another enclave.
	Attestation(ctx context.Context, in *AttestationRequest, opts ...grpc.CallOption) (*AttestationResponse, error)
	// GenerateSecret - the genesis enclave is responsible with generating the secret entropy
	GenerateSecret(ctx context.Context, in *GenerateSecretRequest, opts ...grpc.CallOption) (*GenerateSecretResponse, error)
	// FetchSecret - return the shared secret encrypted with the key from the attestation
	FetchSecret(ctx context.Context, in *FetchSecretRequest, opts ...grpc.CallOption) (*FetchSecretResponse, error)
	// Init - initialise an enclave with a seed received by another enclave
	Init(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitResponse, error)
	// IsInitialised - true if the shared secret is available
	IsInitialised(ctx context.Context, in *IsInitialisedRequest, opts ...grpc.CallOption) (*IsInitialisedResponse, error)
	// ProduceGenesis - the genesis enclave produces the genesis rollup
	ProduceGenesis(ctx context.Context, in *ProduceGenesisRequest, opts ...grpc.CallOption) (*ProduceGenesisResponse, error)
	// IngestBlocks - feed L1 blocks into the enclave to catch up
	IngestBlocks(ctx context.Context, in *IngestBlocksRequest, opts ...grpc.CallOption) (*IngestBlocksResponse, error)
	// Start - start speculative execution
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error)
	// SubmitBlock - When a new POBI round starts, the host submits a block to the enclave, which responds with a rollup
	// it is the responsibility of the host to gossip the returned rollup
	// For good functioning the caller should always submit blocks ordered by height
	// submitting a block before receiving a parent of it, will result in it being ignored
	SubmitBlock(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error)
	// SubmitRollup - receive gossiped rollups
	SubmitRollup(ctx context.Context, in *SubmitRollupRequest, opts ...grpc.CallOption) (*SubmitRollupResponse, error)
	// SubmitTx - user transactions
	SubmitTx(ctx context.Context, in *SubmitTxRequest, opts ...grpc.CallOption) (*SubmitTxResponse, error)
	// Balance - returns the balance of an address with a block delay
	Balance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceResponse, error)
	// RoundWinner - calculates and returns the winner for a round
	RoundWinner(ctx context.Context, in *RoundWinnerRequest, opts ...grpc.CallOption) (*RoundWinnerResponse, error)
	// Stop gracefully stops the enclave
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)
	// GetTransaction returns a transaction given its Signed Hash, returns nil, false when Transaction is unknown
	GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error)
}

type enclaveInternalClient struct {
	cc grpc.ClientConnInterface
}

func NewEnclaveInternalClient(cc grpc.ClientConnInterface) EnclaveInternalClient {
	return &enclaveInternalClient{cc}
}

func (c *enclaveInternalClient) Attestation(ctx context.Context, in *AttestationRequest, opts ...grpc.CallOption) (*AttestationResponse, error) {
	out := new(AttestationResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/Attestation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) GenerateSecret(ctx context.Context, in *GenerateSecretRequest, opts ...grpc.CallOption) (*GenerateSecretResponse, error) {
	out := new(GenerateSecretResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/GenerateSecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) FetchSecret(ctx context.Context, in *FetchSecretRequest, opts ...grpc.CallOption) (*FetchSecretResponse, error) {
	out := new(FetchSecretResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/FetchSecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) Init(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitResponse, error) {
	out := new(InitResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/Init", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) IsInitialised(ctx context.Context, in *IsInitialisedRequest, opts ...grpc.CallOption) (*IsInitialisedResponse, error) {
	out := new(IsInitialisedResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/IsInitialised", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) ProduceGenesis(ctx context.Context, in *ProduceGenesisRequest, opts ...grpc.CallOption) (*ProduceGenesisResponse, error) {
	out := new(ProduceGenesisResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/ProduceGenesis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) IngestBlocks(ctx context.Context, in *IngestBlocksRequest, opts ...grpc.CallOption) (*IngestBlocksResponse, error) {
	out := new(IngestBlocksResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/IngestBlocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error) {
	out := new(StartResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) SubmitBlock(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error) {
	out := new(SubmitBlockResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/SubmitBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) SubmitRollup(ctx context.Context, in *SubmitRollupRequest, opts ...grpc.CallOption) (*SubmitRollupResponse, error) {
	out := new(SubmitRollupResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/SubmitRollup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) SubmitTx(ctx context.Context, in *SubmitTxRequest, opts ...grpc.CallOption) (*SubmitTxResponse, error) {
	out := new(SubmitTxResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/SubmitTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) Balance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceResponse, error) {
	out := new(BalanceResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/Balance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) RoundWinner(ctx context.Context, in *RoundWinnerRequest, opts ...grpc.CallOption) (*RoundWinnerResponse, error) {
	out := new(RoundWinnerResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/RoundWinner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {
	out := new(StopResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enclaveInternalClient) GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error) {
	out := new(GetTransactionResponse)
	err := c.cc.Invoke(ctx, "/rpc.EnclaveInternal/GetTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EnclaveInternalServer is the server API for EnclaveInternal service.
// All implementations must embed UnimplementedEnclaveInternalServer
// for forward compatibility
type EnclaveInternalServer interface {
	// Attestation - Produces an attestation report which will be used to request the shared secret from another enclave.
	Attestation(context.Context, *AttestationRequest) (*AttestationResponse, error)
	// GenerateSecret - the genesis enclave is responsible with generating the secret entropy
	GenerateSecret(context.Context, *GenerateSecretRequest) (*GenerateSecretResponse, error)
	// FetchSecret - return the shared secret encrypted with the key from the attestation
	FetchSecret(context.Context, *FetchSecretRequest) (*FetchSecretResponse, error)
	// Init - initialise an enclave with a seed received by another enclave
	Init(context.Context, *InitRequest) (*InitResponse, error)
	// IsInitialised - true if the shared secret is available
	IsInitialised(context.Context, *IsInitialisedRequest) (*IsInitialisedResponse, error)
	// ProduceGenesis - the genesis enclave produces the genesis rollup
	ProduceGenesis(context.Context, *ProduceGenesisRequest) (*ProduceGenesisResponse, error)
	// IngestBlocks - feed L1 blocks into the enclave to catch up
	IngestBlocks(context.Context, *IngestBlocksRequest) (*IngestBlocksResponse, error)
	// Start - start speculative execution
	Start(context.Context, *StartRequest) (*StartResponse, error)
	// SubmitBlock - When a new POBI round starts, the host submits a block to the enclave, which responds with a rollup
	// it is the responsibility of the host to gossip the returned rollup
	// For good functioning the caller should always submit blocks ordered by height
	// submitting a block before receiving a parent of it, will result in it being ignored
	SubmitBlock(context.Context, *SubmitBlockRequest) (*SubmitBlockResponse, error)
	// SubmitRollup - receive gossiped rollups
	SubmitRollup(context.Context, *SubmitRollupRequest) (*SubmitRollupResponse, error)
	// SubmitTx - user transactions
	SubmitTx(context.Context, *SubmitTxRequest) (*SubmitTxResponse, error)
	// Balance - returns the balance of an address with a block delay
	Balance(context.Context, *BalanceRequest) (*BalanceResponse, error)
	// RoundWinner - calculates and returns the winner for a round
	RoundWinner(context.Context, *RoundWinnerRequest) (*RoundWinnerResponse, error)
	// Stop gracefully stops the enclave
	Stop(context.Context, *StopRequest) (*StopResponse, error)
	// GetTransaction returns a transaction given its Signed Hash, returns nil, false when Transaction is unknown
	GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error)
	mustEmbedUnimplementedEnclaveInternalServer()
}

// UnimplementedEnclaveInternalServer must be embedded to have forward compatible implementations.
type UnimplementedEnclaveInternalServer struct {
}

func (UnimplementedEnclaveInternalServer) Attestation(context.Context, *AttestationRequest) (*AttestationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attestation not implemented")
}
func (UnimplementedEnclaveInternalServer) GenerateSecret(context.Context, *GenerateSecretRequest) (*GenerateSecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateSecret not implemented")
}
func (UnimplementedEnclaveInternalServer) FetchSecret(context.Context, *FetchSecretRequest) (*FetchSecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchSecret not implemented")
}
func (UnimplementedEnclaveInternalServer) Init(context.Context, *InitRequest) (*InitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Init not implemented")
}
func (UnimplementedEnclaveInternalServer) IsInitialised(context.Context, *IsInitialisedRequest) (*IsInitialisedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsInitialised not implemented")
}
func (UnimplementedEnclaveInternalServer) ProduceGenesis(context.Context, *ProduceGenesisRequest) (*ProduceGenesisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProduceGenesis not implemented")
}
func (UnimplementedEnclaveInternalServer) IngestBlocks(context.Context, *IngestBlocksRequest) (*IngestBlocksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IngestBlocks not implemented")
}
func (UnimplementedEnclaveInternalServer) Start(context.Context, *StartRequest) (*StartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (UnimplementedEnclaveInternalServer) SubmitBlock(context.Context, *SubmitBlockRequest) (*SubmitBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitBlock not implemented")
}
func (UnimplementedEnclaveInternalServer) SubmitRollup(context.Context, *SubmitRollupRequest) (*SubmitRollupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitRollup not implemented")
}
func (UnimplementedEnclaveInternalServer) SubmitTx(context.Context, *SubmitTxRequest) (*SubmitTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTx not implemented")
}
func (UnimplementedEnclaveInternalServer) Balance(context.Context, *BalanceRequest) (*BalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Balance not implemented")
}
func (UnimplementedEnclaveInternalServer) RoundWinner(context.Context, *RoundWinnerRequest) (*RoundWinnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoundWinner not implemented")
}
func (UnimplementedEnclaveInternalServer) Stop(context.Context, *StopRequest) (*StopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedEnclaveInternalServer) GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransaction not implemented")
}
func (UnimplementedEnclaveInternalServer) mustEmbedUnimplementedEnclaveInternalServer() {}

// UnsafeEnclaveInternalServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EnclaveInternalServer will
// result in compilation errors.
type UnsafeEnclaveInternalServer interface {
	mustEmbedUnimplementedEnclaveInternalServer()
}

func RegisterEnclaveInternalServer(s grpc.ServiceRegistrar, srv EnclaveInternalServer) {
	s.RegisterService(&EnclaveInternal_ServiceDesc, srv)
}

func _EnclaveInternal_Attestation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).Attestation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/Attestation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).Attestation(ctx, req.(*AttestationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_GenerateSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).GenerateSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/GenerateSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).GenerateSecret(ctx, req.(*GenerateSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_FetchSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).FetchSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/FetchSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).FetchSecret(ctx, req.(*FetchSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_Init_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).Init(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/Init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).Init(ctx, req.(*InitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_IsInitialised_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsInitialisedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).IsInitialised(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/IsInitialised",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).IsInitialised(ctx, req.(*IsInitialisedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_ProduceGenesis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProduceGenesisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).ProduceGenesis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/ProduceGenesis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).ProduceGenesis(ctx, req.(*ProduceGenesisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_IngestBlocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestBlocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).IngestBlocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/IngestBlocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).IngestBlocks(ctx, req.(*IngestBlocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).Start(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_SubmitBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).SubmitBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/SubmitBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).SubmitBlock(ctx, req.(*SubmitBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_SubmitRollup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitRollupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).SubmitRollup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/SubmitRollup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).SubmitRollup(ctx, req.(*SubmitRollupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_SubmitTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).SubmitTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/SubmitTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).SubmitTx(ctx, req.(*SubmitTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_Balance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).Balance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/Balance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).Balance(ctx, req.(*BalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_RoundWinner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoundWinnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).RoundWinner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/RoundWinner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).RoundWinner(ctx, req.(*RoundWinnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnclaveInternal_GetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnclaveInternalServer).GetTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.EnclaveInternal/GetTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnclaveInternalServer).GetTransaction(ctx, req.(*GetTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EnclaveInternal_ServiceDesc is the grpc.ServiceDesc for EnclaveInternal service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EnclaveInternal_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.EnclaveInternal",
	HandlerType: (*EnclaveInternalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Attestation",
			Handler:    _EnclaveInternal_Attestation_Handler,
		},
		{
			MethodName: "GenerateSecret",
			Handler:    _EnclaveInternal_GenerateSecret_Handler,
		},
		{
			MethodName: "FetchSecret",
			Handler:    _EnclaveInternal_FetchSecret_Handler,
		},
		{
			MethodName: "Init",
			Handler:    _EnclaveInternal_Init_Handler,
		},
		{
			MethodName: "IsInitialised",
			Handler:    _EnclaveInternal_IsInitialised_Handler,
		},
		{
			MethodName: "ProduceGenesis",
			Handler:    _EnclaveInternal_ProduceGenesis_Handler,
		},
		{
			MethodName: "IngestBlocks",
			Handler:    _EnclaveInternal_IngestBlocks_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _EnclaveInternal_Start_Handler,
		},
		{
			MethodName: "SubmitBlock",
			Handler:    _EnclaveInternal_SubmitBlock_Handler,
		},
		{
			MethodName: "SubmitRollup",
			Handler:    _EnclaveInternal_SubmitRollup_Handler,
		},
		{
			MethodName: "SubmitTx",
			Handler:    _EnclaveInternal_SubmitTx_Handler,
		},
		{
			MethodName: "Balance",
			Handler:    _EnclaveInternal_Balance_Handler,
		},
		{
			MethodName: "RoundWinner",
			Handler:    _EnclaveInternal_RoundWinner_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _EnclaveInternal_Stop_Handler,
		},
		{
			MethodName: "GetTransaction",
			Handler:    _EnclaveInternal_GetTransaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go/obscuronode/enclave/rpc/enclave.proto",
}
